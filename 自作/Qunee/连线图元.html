<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>edge</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
<script src="http://demo.qunee.com/lib/qunee-min.js"></script>
</head>
<body>
    <div id="canvas"
		 style="margin: 0 auto;width: 80%;height: 600px;box-shadow: 0 0 0 2px rgba(0, 0, 0, .4)"></div>

	<script type="text/javascript">
		var graph = new Q.Graph('canvas');

		var nodeA = graph.createNode('AAAA', 0, -200);
		var nodeB = graph.createNode('BBBB', 0, 200);

		/**
		 * 创建连线
		 * createEdge(from, to, name)
		 */
		 var edgeA_B = graph.createEdge(nodeA, nodeB, 'edgeA_B');

		 /**
		 * 创建连线
		 * new Q.Edge(from, to, name)
		 */
		 var nodeC = new Q.Node('CCC', -200, 0);

		 graph.graphModel.add(nodeC);

		 var edgeB_C = new Q.Edge(nodeB, nodeC, 'edgeB_C');

		 graph.graphModel.add(edgeB_C);
		 console.log(edgeB_C.isConnected());
		 edgeB_C.disconnect();
		 console.log(edgeB_C.isConnected());

		 /**
  		  * 子网
		  */

		  var nodeParent = graph.createNode('Parent(点击计入详情)', 0, 0);

		  nodeParent.enableSubNetwork = !0;
		  nodeParent.addChild(nodeA);
		  // nodeA.parent = nodeParent;
		  nodeB.parent = nodeParent;
		  edgeA_B.parent = nodeParent;

		  graph.onPropertyChange('currentSubNetwork', function(e) {
		  	graph.html.style.backgroundColor = graph.currentSubNetwork == nodeParent ? '#DDF' : '#FFF';
		  })

		  graph.maxScale = 1;

		  /** 坐标原点在几何中心(0, 0) 正负跟css left top 表现一致 **/
		  /** 同时设定两连接 **/
		  var node1 = graph.createNode('node1', -200, -200);
		  var node2 = graph.createNode('node2', 0, 200);
		  var edge1_2 = graph.createEdge(node1, node2, 'edge1_2');
		  var edge2_1 = graph.createEdge(node1, node2, 'edge2_1');
		  var bundleEdges = edge1_2.getEdgeBundle();
		  console.log('Q', Q);
		  // edge1_2.setStyle(Q.Styles.EDGE_COLOR, '#ff0000');
		  // edge1_2.setStyle(Q.Styles.ARROW_FROM, true);
		  // edge1_2.setStyle(Q.Styles.ARROW_FROM_OFFSET, {x: 0.5});
		  edge1_2.setStyle(Q.Styles.ARROW_TO_OFFSET, {x: -0.5});
		  edge1_2.setStyle(Q.Styles.ARROW_TO_STROKE_STYLE, '#f00');
		  edge1_2.setStyle(Q.Styles.EDGE_LINE_DASH, [8, 1]);
		  edge1_2.setStyle(Q.Styles.EDGE_OUTLINE, 1);
		  edge1_2.setStyle(Q.Styles.EDGE_OUTLINE_STYLE, '#0f0');

		  var lineOffset = 1;
		  setInterval(() => {
		  	edge1_2.setStyle(Q.Styles.EDGE_LINE_DASH_OFFSET, lineOffset--);
		  }, 100);

		  var arrowOffset = -.95;
		  edge2_1.setStyle(Q.Styles.ARROW_TO_OFFSET, {x: arrowOffset});
		  setInterval(() => {
		  	arrowOffset += .01;
		  	arrowOffset = arrowOffset > -.05 ? -.95 : arrowOffset;

		  	edge2_1.setStyle(Q.Styles.ARROW_TO_OFFSET, {x: arrowOffset});
		  }, 100);

		  // edge1_2.addPathSegment([-210, -200], null, 1);
		  // edge1_2.addPathSegment([-10, 200], null, 2);

		  // edge2_1.addPathSegment([-190, -200]);
		  // edge2_1.addPathSegment([10, 200]);

		  // removePathSegmentByIndex
		  // setTimeout(() => {
		  // 	edge1_2.removePathSegmentByIndex(1);
		  // 	edge1_2.removePathSegmentByIndex(2);
		  // }, 1000);
		  console.log(Q.Styles);
		  graph.editable = true;

          graph.isEditable = (node) => {
          	return !(node instanceof Q.Edge);
          }
	</script>
</body>
</html>